//
// File: CompactClassificationEnsemble.cpp
//
// MATLAB Coder version            : 5.2
// C/C++ source code generated on  : 25-Dec-2021 13:54:41
//

// Include Files
#include "CompactClassificationEnsemble.h"
#include "aggregatePredict.h"
#include "rt_nonfinite.h"
#include "coder_array.h"
#include <cmath>

// Function Definitions
//
// Arguments    : void
// Return Type  : void
//
namespace coder {
namespace classreg {
namespace learning {
namespace classif {
void CompactClassificationEnsemble::init()
{
  static const double a[400]{
      1.2359846135843069,  0.71698476777613063, 0.56335852095618733,
      0.46052108204640163, 0.37873698436232456, 0.48646007131704438,
      0.36898604315374972, 0.38728509679130452, 0.41834331812464687,
      0.3956101850432569,  0.4458335806228837,  0.35475660024545252,
      0.39571214983992714, 0.34127939602747809, 0.38278924861373875,
      0.42774619329282793, 0.32938909010463041, 0.39212064374684963,
      0.36503750792673767, 0.31892434768931877, 0.37288887283143,
      0.32529516087545707, 0.34231972939604416, 0.39632278262810627,
      0.24872247536876374, 0.41167341543937541, 0.2946203102909008,
      0.29539104673687011, 0.37155392270990317, 0.32770105918878073,
      0.342172995513081,   0.33802021593713183, 0.33978470486369727,
      0.26523247719991921, 0.33001453328123992, 0.30154239095879659,
      0.31859499660439128, 0.3532792112968951,  0.341858038430153,
      0.33867053726179358, 0.31413427060418531, 0.35141617733211516,
      0.27507650567988012, 0.31135197946105025, 0.3114244950049917,
      0.30499445385226259, 0.22174659007141698, 0.28111996334846245,
      0.3191910117723335,  0.31708815956347275, 0.28116280601539051,
      0.35892119715597476, 0.26588746776221123, 0.321558088057422,
      0.27646113130517341, 0.31600444855190751, 0.35373859223781795,
      0.33280567655542959, 0.29956916337079048, 0.35801440449602728,
      0.28707351588488872, 0.28298546289249682, 0.26853304969684372,
      0.30120334114260117, 0.28608807861711505, 0.32184613457571531,
      0.33364213446557178, 0.30475140326061084, 0.2808326114963372,
      0.29308004729382947, 0.28682712023724816, 0.31295213859048049,
      0.32606915618533244, 0.30736756939115273, 0.30237625867035478,
      0.31294545425528986, 0.28524049810968344, 0.32460832209664431,
      0.3337113624281226,  0.33837461598261914, 0.29045468562840887,
      0.30718194293163625, 0.29730012899349617, 0.3512933375748854,
      0.29368886675967976, 0.28203296094667452, 0.28188285377814193,
      0.31105404590078772, 0.2615696713721492,  0.34588910860112759,
      0.21129072263588067, 0.33229101470693129, 0.30326843753638533,
      0.32056315393466545, 0.20371019228470255, 0.31893779038347708,
      0.34483144771249036, 0.23496976883501206, 0.25526885704954688,
      0.2597619202468946,  0.28983969734378151, 0.33930274952577089,
      0.2736137001086596,  0.31879411428867066, 0.31595057746549349,
      0.27860522508237029, 0.27244939795555634, 0.31088545087997804,
      0.285447615958394,   0.31421268188468665, 0.27781458573783124,
      0.33724127300976231, 0.25376625007824266, 0.30228674724068005,
      0.32034602842637255, 0.2864635371767561,  0.29210543650030735,
      0.318340035735345,   0.33726889723907916, 0.27042384857652413,
      0.28851925326880362, 0.24006273415645479, 0.32948513325072409,
      0.28677679215221435, 0.36084545413951885, 0.32791181962350041,
      0.25751928659556422, 0.27881003865361786, 0.358155113690314,
      0.28829249667337548, 0.31937595951322639, 0.40612595739192153,
      0.20532955937469877, 0.27102579296946772, 0.31607158634698013,
      0.31020446098755461, 0.33939616819577018, 0.3302971093341685,
      0.29541254915436754, 0.32170678387274676, 0.31127296529003029,
      0.36584548051732035, 0.3030200044576139,  0.3232900840472373,
      0.3016172143930434,  0.3216820683592066,  0.26581319388709457,
      0.3099057368132539,  0.25714201636930556, 0.27872215877510853,
      0.27144164887481503, 0.30400712242738409, 0.35479722207671538,
      0.35051292066003109, 0.273802037945654,   0.24296265850420279,
      0.29104450167994306, 0.3534639919079145,  0.27242494512607812,
      0.31331166461612114, 0.34915082626444266, 0.293849662201075,
      0.34329038232546993, 0.27021764038091828, 0.266153457666192,
      0.30479642555104725, 0.23709966013472741, 0.31603744862277794,
      0.37139054702183072, 0.26755648100751822, 0.293984903409887,
      0.27669596585349093, 0.31101334153039628, 0.26068970050750434,
      0.32699033346153716, 0.336151707919746,   0.22266715211707749,
      0.309934087566339,   0.34138390291552623, 0.29355134031681884,
      0.3433627889071853,  0.34023389287924471, 0.305113141817291,
      0.23893584473683147, 0.28013212980980345, 0.29825358869454033,
      0.28701150360674771, 0.28976614284718949, 0.26875061729808769,
      0.30428579049847,    0.32914413134865927, 0.22233898808533709,
      0.26350788263375352, 0.19455695601636688, 0.21617105528979705,
      0.22343968271080281, 0.19315220449171544, 0.33379544876485157,
      0.23103629051607735, 0.3307223385078949,  0.28881352838459778,
      0.31995378939196378, 0.23511978194950817, 0.31212860303704237,
      0.30605137259758258, 0.27536687373823976, 0.29901776248930689,
      0.2616399309068877,  0.34321685528969514, 0.31632594717032714,
      0.27714846187193309, 0.29919883645427831, 0.29714144121917579,
      0.36531270383768305, 0.30542839934878319, 0.30685698230854253,
      0.32179671605392524, 0.278988659188231,   0.27707619005500317,
      0.31988934233944827, 0.30300015873909475, 0.25622768962827941,
      0.356234379312214,   0.30939667311555741, 0.25892001319902569,
      0.27621586769195228, 0.24566310756696069, 0.2695571870397872,
      0.24472209252030497, 0.32365078333400155, 0.33327670843359458,
      0.28352742894145733, 0.23915065318962442, 0.27229135628439805,
      0.29248176959826161, 0.30774061032682037, 0.22892960902378162,
      0.33535898691763449, 0.24117775800407298, 0.31313305568266758,
      0.3166140641755868,  0.33748232814542123, 0.2700468385142421,
      0.26212845148969821, 0.3498830093871213,  0.29168770405375494,
      0.33405132642992896, 0.27268367245352282, 0.24282703011916584,
      0.33212610853497188, 0.279632096232131,   0.32630741333259322,
      0.33618777251421439, 0.37748797764901171, 0.26901966381027376,
      0.30683210503336156, 0.2738716518288552,  0.30993486324847086,
      0.31749809300318971, 0.30103540917135968, 0.32500061790577756,
      0.3034690602864592,  0.28299028133546478, 0.29438485464937447,
      0.28615398003255577, 0.29977895953559908, 0.28705200055511471,
      0.26756483259728181, 0.3275846265223788,  0.24713189617286999,
      0.29237892840958,    0.26214755020317776, 0.25873456562486,
      0.27056403477855206, 0.32873970105197,    0.30021730506112349,
      0.33025006550582992, 0.27216127797206618, 0.25565133797405482,
      0.28065150019446233, 0.29734634918489211, 0.24370236760309869,
      0.24694062559435703, 0.30717648216396348, 0.26524272036016078,
      0.2439940104075646,  0.2585215441615285,  0.21738470416564651,
      0.25570050613273376, 0.314519494744242,   0.30635975064747517,
      0.22660586662915083, 0.31764347526079145, 0.2901574802768731,
      0.29168032080625905, 0.28499416120415438, 0.27314459791030621,
      0.27295014981641796, 0.27438653203712771, 0.35701386035948979,
      0.30626843256904945, 0.26805889862856896, 0.28290688322206953,
      0.36034434408615451, 0.25263626789030391, 0.25498566213842422,
      0.28146586916151639, 0.30640722106759721, 0.32989906865916985,
      0.30637351899475967, 0.29762582369451224, 0.30100884165276615,
      0.24480423991596753, 0.22052619807658164, 0.32383186236242351,
      0.37181825864151513, 0.23942286767360954, 0.25863741917184491,
      0.26173967254680225, 0.31404932179487233, 0.26780403874583592,
      0.32733665704001352, 0.39743490408829868, 0.31990644154126791,
      0.28867174046545463, 0.32542282161298652, 0.28226271568428773,
      0.27113707804024251, 0.31724722259866278, 0.27565947022296811,
      0.2256179718796415,  0.23715129530498613, 0.32606360342586471,
      0.28177911849299531, 0.28052478499378075, 0.31164498131223223,
      0.27589246247684862, 0.35945492211717162, 0.23713859103155463,
      0.27400724390219855, 0.22872781062026037, 0.29968997468837483,
      0.36193728341792913, 0.32773279271921751, 0.24579433267960682,
      0.29009924144516247, 0.28821026061663374, 0.29910968639870561,
      0.30334712232727373, 0.28598404701633823, 0.28496022817412614,
      0.28459304477434932, 0.30864420117478641, 0.29919781218393948,
      0.25887831304929088, 0.30753442647870716, 0.32379962333708723,
      0.2306139814729426,  0.357572460198628,   0.27025903500026716,
      0.32005273467385353, 0.25514187161654833, 0.20184156373545833,
      0.20113668595490269, 0.27716296628847886, 0.29615337130043495,
      0.23051723063265195, 0.26114359012921573, 0.27985809916367332,
      0.31875489638169124, 0.29695395586159123, 0.29749808006179868,
      0.28346647884232523, 0.24747544418466438, 0.27856897099148842,
      0.34085688268257974, 0.28407340873449016, 0.31376137008213578,
      0.25689116298433545, 0.2723816459150129,  0.21260292449011065,
      0.31406936470536834, 0.21614322670235686, 0.29784263783143383,
      0.26726604308782309, 0.34403153067117115, 0.32893070798830021,
      0.29774875805604278, 0.33755030107938888, 0.38368593819840935,
      0.33016222016775032, 0.276524353881222,   0.29738494346667438,
      0.24696799661384372, 0.30516214530701324, 0.20914435970085055,
      0.2357044741444011,  0.16144872247843056, 0.27200891930177068,
      0.26699408216869974};
  this->ClassNames[0] = 0.0;
  this->ClassNamesLength[0] = 1;
  this->ClassLogicalIndices[0] = true;
  this->ClassNames[1] = 1.0;
  this->ClassNamesLength[1] = 1;
  this->ClassLogicalIndices[1] = true;
  this->ScoreTransform = coderutils::Identity;
  for (int i{0}; i < 400; i++) {
    this->LearnerWeights[i] = a[i];
    this->IsCached[i] = false;
  }
  this->Prior[0] = 0.38651502107027957;
  this->Prior[1] = 0.61348497892972043;
  this->Cost[0] = 0.0;
  this->Cost[1] = 1.0;
  this->Cost[2] = 1.0;
  this->Cost[3] = 0.0;
}

//
// Arguments    : const ::coder::array<double, 2U> &Xin
//                ::coder::array<double, 1U> &labels
// Return Type  : void
//
void CompactClassificationEnsemble::predict(
    const ::coder::array<double, 2U> &Xin,
    ::coder::array<double, 1U> &labels) const
{
  array<double, 2U> scoreIn;
  array<double, 1U> classnum;
  array<boolean_T, 2U> b;
  array<boolean_T, 2U> r;
  array<boolean_T, 1U> notNaN;
  double d1;
  int idx;
  int iindx;
  unsigned int u1;
  boolean_T bv[400];
  if (Xin.size(0) == 0) {
    labels.set_size(0);
  } else {
    int i1;
    int i2;
    int outsize_idx_0;
    scoreIn.set_size(Xin.size(0), 2);
    i2 = Xin.size(0) << 1;
    if (static_cast<int>(i2 < 1200)) {
      for (iindx = 0; iindx < i2; iindx++) {
        scoreIn[iindx] = 0.0;
      }
    } else {
#pragma omp parallel for num_threads(omp_get_max_threads()) private(iindx)

      for (iindx = 0; iindx < i2; iindx++) {
        scoreIn[iindx] = 0.0;
      }
    }
    for (outsize_idx_0 = 0; outsize_idx_0 < 400; outsize_idx_0++) {
      bv[outsize_idx_0] = true;
    }
    r.set_size(Xin.size(0), 400);
    i2 = Xin.size(0) * 400;
    if (static_cast<int>(i2 < 1200)) {
      for (iindx = 0; iindx < i2; iindx++) {
        r[iindx] = true;
      }
    } else {
#pragma omp parallel for num_threads(omp_get_max_threads()) private(iindx)

      for (iindx = 0; iindx < i2; iindx++) {
        r[iindx] = true;
      }
    }
    coder::ensembleutils::aggregatePredict(Xin, scoreIn, this->LearnerWeights,
                                           this->IsCached, this->ClassNames, bv,
                                           r);
    b.set_size(scoreIn.size(0), 2);
    i2 = scoreIn.size(0) * 2;
    if (static_cast<int>(i2 < 1200)) {
      for (iindx = 0; iindx < i2; iindx++) {
        b[iindx] = std::isnan(scoreIn[iindx]);
      }
    } else {
#pragma omp parallel for num_threads(omp_get_max_threads()) private(iindx)

      for (iindx = 0; iindx < i2; iindx++) {
        b[iindx] = std::isnan(scoreIn[iindx]);
      }
    }
    outsize_idx_0 = b.size(0);
    notNaN.set_size(b.size(0));
    i2 = b.size(0);
    if (static_cast<int>(b.size(0) < 1200)) {
      for (iindx = 0; iindx < outsize_idx_0; iindx++) {
        notNaN[iindx] = true;
      }
    } else {
#pragma omp parallel for num_threads(omp_get_max_threads()) private(iindx)

      for (iindx = 0; iindx < i2; iindx++) {
        notNaN[iindx] = true;
      }
    }
    outsize_idx_0 = b.size(0);
    i2 = b.size(0);
    i1 = 0;
    for (int j{0}; j < outsize_idx_0; j++) {
      int ix;
      boolean_T exitg1;
      i1++;
      i2++;
      ix = i1;
      exitg1 = false;
      while ((!exitg1) && ((outsize_idx_0 > 0) && (ix <= i2))) {
        if (!b[ix - 1]) {
          notNaN[j] = false;
          exitg1 = true;
        } else {
          ix += outsize_idx_0;
        }
      }
    }
    i2 = notNaN.size(0);
    if (static_cast<int>(notNaN.size(0) < 1200)) {
      for (iindx = 0; iindx < i2; iindx++) {
        notNaN[iindx] = !notNaN[iindx];
      }
    } else {
#pragma omp parallel for num_threads(omp_get_max_threads()) private(iindx)

      for (iindx = 0; iindx < i2; iindx++) {
        notNaN[iindx] = !notNaN[iindx];
      }
    }
    if ((this->Prior[0] < this->Prior[1]) ||
        (std::isnan(this->Prior[0]) && (!std::isnan(this->Prior[1])))) {
      i1 = 1;
    } else {
      i1 = 0;
    }
    classnum.set_size(scoreIn.size(0));
    i2 = scoreIn.size(0);
    if (static_cast<int>(scoreIn.size(0) < 1200)) {
      for (iindx = 0; iindx < i2; iindx++) {
        classnum[iindx] = rtNaN;
      }
    } else {
#pragma omp parallel for num_threads(omp_get_max_threads()) private(iindx)

      for (iindx = 0; iindx < i2; iindx++) {
        classnum[iindx] = rtNaN;
      }
    }
    outsize_idx_0 = notNaN.size(0);
    if (static_cast<int>(notNaN.size(0) < 1200)) {
      for (idx = 0; idx < outsize_idx_0; idx++) {
        if (notNaN[idx]) {
          if ((scoreIn[idx] < scoreIn[idx + scoreIn.size(0)]) ||
              (std::isnan(scoreIn[idx]) &&
               (!std::isnan(scoreIn[idx + scoreIn.size(0)])))) {
            iindx = 2;
          } else {
            iindx = 1;
          }
          classnum[idx] = iindx;
        }
      }
    } else {
#pragma omp parallel for num_threads(omp_get_max_threads()) private(iindx, idx)

      for (idx = 0; idx < outsize_idx_0; idx++) {
        if (notNaN[idx]) {
          if ((scoreIn[idx] < scoreIn[idx + scoreIn.size(0)]) ||
              (std::isnan(scoreIn[idx]) &&
               (!std::isnan(scoreIn[idx + scoreIn.size(0)])))) {
            iindx = 2;
          } else {
            iindx = 1;
          }
          classnum[idx] = iindx;
        }
      }
    }
    labels.set_size(scoreIn.size(0));
    i2 = scoreIn.size(0);
    if (static_cast<int>(scoreIn.size(0) < 1200)) {
      for (iindx = 0; iindx < i2; iindx++) {
        labels[iindx] = this->ClassNames[i1];
      }
    } else {
#pragma omp parallel for num_threads(omp_get_max_threads()) private(iindx)

      for (iindx = 0; iindx < i2; iindx++) {
        labels[iindx] = this->ClassNames[i1];
      }
    }
    outsize_idx_0 = notNaN.size(0);
    if (static_cast<int>(notNaN.size(0) < 1200)) {
      for (idx = 0; idx < outsize_idx_0; idx++) {
        if (notNaN[idx]) {
          double d;
          unsigned int u;
          d = classnum[idx];
          if (d < 4.294967296E+9) {
            u = static_cast<unsigned int>(d);
          } else {
            u = 0U;
          }
          labels[idx] = this->ClassNames[static_cast<int>(u) - 1];
        }
      }
    } else {
#pragma omp parallel for num_threads(omp_get_max_threads()) private(idx, d1, u1)

      for (idx = 0; idx < outsize_idx_0; idx++) {
        if (notNaN[idx]) {
          d1 = classnum[idx];
          if (d1 < 4.294967296E+9) {
            u1 = static_cast<unsigned int>(d1);
          } else {
            u1 = 0U;
          }
          labels[idx] = this->ClassNames[static_cast<int>(u1) - 1];
        }
      }
    }
  }
}

} // namespace classif
} // namespace learning
} // namespace classreg
} // namespace coder

//
// File trailer for CompactClassificationEnsemble.cpp
//
// [EOF]
//
